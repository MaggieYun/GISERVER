#coding=utf-8
#author 许照云
from functools import partial
from graphic import *
from extent import *
import copy

from validation import *

class TableCache(object):
    '''
    Database Table(or view) Cache Class

    '''
    SQL = "SELECT %s from %s"
    GEOSQL = "SELECT ST_AsGeoJSON(%s) from %s"

    def __init__(self,ini,layer):
        '''
        isTable=True可根据ini中的信息来判断
        '''
        self.validation = Validation(ini)

        self.engine = self.validation.engine

        self.name = ini.scheme_name     #数据库中表名，也做此表layer的名字
        self.ini = ini   #该TableCache实例是哪个layer的缓存
        self.layer = layer

        self.scheme_type = ini.scheme_type


    def query(self,queryParameter):
        '''
        根据选择条件和返回字段,查询记录.
        @queryParameter:QueryParameter类的实例，每一次query的查询条件
        需要从layer的缓存FEATURES中过滤提取有效字段，而不是从results
        '''
        #以下三要素相当于selector的主要内容，可改造成selector
        extent = Extent(queryParameter.bbox)      #bbox
        where = queryParameter.where             #where 
        outfields = queryParameter.outfields     #outfields    (尚未考虑insr,outsr)
        insr = queryParameter.insr

        #获取aliases,fields
        aliases_dict = self.ini.aliases          #aliases_dict>outfields
        aliases_dict_keys = aliases_dict.keys()
        
        # tableCache = TableCache(self.engine,self.name)
        aliases=["SHAPE"]            #顺序按照outfields的顺序,使用列表是为了保证顺序
        if self.ini.x_field:  #普通数据库
            features = copy.deepcopy(self.layer.FEATURES)


            if len(features) == 0:    #如果尚无缓存则从数据库取出数据
                features = copy.deepcopy(self.sync(queryParameter))  #为何同步实例化时传了两个参数？？

            results = []    
            for feature in features['features']:
                if extent.contain(feature['geometry']['coordinates']):  #过滤bbox
                    results.append(feature) 

            import re                                          #过滤where条件
            p=re.compile(r'\[(\w+)\]')
            para = p.findall(where)                            #where条件，程序则要求过滤的是attributes中的属性，不能再包含shape
            n=len(str(para))  #以下条件有待改善
            filter_where = eval("lambda feature:feature['properties']['%s']%s"%(para[0],where[n+2:]))
            results=filter(filter_where,results) 

            


            #用户url中传来的参数outfields中不必（也不能）包含x，y字段，会自动查询并显示。
            features = []  
            fields = outfields[:]
            fields.insert(0,'SHAPE')
            isgot_fields = True    #布尔型，True表示尚未获得aliases和fields信息
            if outfields[0] is not "*":             #暂且默认queryResult里必然包含x,y字段（即geometry属性）
                for result in results:                  #注意保持取出字段的排列顺序
                    one_result =[]                      #一个graphic的attributes中应取出的outfields字段
                    one_result.append(result['geometry']['coordinates'])   #首先将location字段添加
                    for outfield in outfields:             #按道理outfields必然是self.fileds的子集
                        #获取fields、aliases数据
                        if isgot_fields:          #目的是提高效率，效果不大。
                            if outfield in aliases_dict_keys:
                                aliases.append(aliases_dict.get(outfield))
                            else:
                                aliases.append(outfield)

                        # 获取features要素的所有信息    
                        one = result['properties'].get(outfield)
                        if one:                             #验证一下attributes中是否包含该字段。
                            one_result.append(one)
                        else:
                            one_result.append("null")
                    
                    #提取fields、aliases信息只需遍历一遍outfields
                    isgot_fields = False  


                    features.append(one_result)             #二维数组 
            else:    
                
                features= reduce(lambda x,y:x+y,
                                map(lambda x:[x['properties'].values()],
                                            results))   #去除键，重新组织键值 
                n = len(features)
                for i in range(n) :
                    features[i].insert(0,results[i]['geometry']['coordinates'])
                
                fields = results[0]['properties'].keys()
                fields.insert(0,"SHAPE")
                aliases = []
                for field in fields:
                    aliase = aliases_dict.get(field)
                    if aliase:
                        aliases.append(aliase)
                    else:
                        aliases.append(field)


        elif self.ini.g_field:   #空间数据库直接进行空间查询，再结合aliases重新组织下数据（不用实现sync）
            isgot_fields = True 
            results = self.sync(queryParameter)
            features = []
            outfields = map(lambda x:x.upper(),outfields)
            fields = outfields[:]
            fields.insert(0,'SHAPE')

            for result in results['features']:
                one_result =[]                     
                one_result.append(result['geometry']['coordinates']) 
                
                
                for outfield in outfields:             #按道理outfields必然是self.fileds的子集
                    #获取fields、aliases数据
                    if isgot_fields:          #目的是提高效率，效果不大。
                        if outfield in aliases_dict_keys:
                            aliases.append(aliases_dict.get(outfield))
                        else:
                            aliases.append(outfield)
                    # 获取features要素的所有信息    
                    one = result['properties'].get(outfield)
                    if one:                             #验证一下attributes中是否包含该字段。
                        one_result.append(one)
                    else:
                        one_result.append("null")
                #提取fields、aliases信息只需遍历一遍outfields
                isgot_fields = False 

                features.append(one_result)             #二维数组 

        
        return aliases,fields,features


    def sync(self,queryParameter):
        '''
        同步数据库,从数据库中获取最新的记录;可以指定同步字段,默认同步所有字段信息;
        ?是否需要在第一次调用时,强制同步所有字段信息.
            Y:  之后的查询可以支持任何字段值的返回,但不保证数据的实时性;
            N:  会加载不必要的数据,占用过多系统资源;
            
        @param {list<str>} fields 更新字段列表
        '''

        
        conn = self.engine.connect()
        if self.ini.x_field:
            fields = "*" #全部取出
            results = conn.execute(self.SQL%(fields,self.name))
        elif self.ini.g_field:
            #以下三要素相当于selector的主要内容，可改造成selector
            extent = Extent(queryParameter.bbox)      #bbox
            where = queryParameter.where             #where    
            outfields = queryParameter.outfields     #outfields    (尚未考虑insr,outsr)
            insr = queryParameter.insr

            extentText = extent.toText()
            # print extentText
            outfields = ",".join(outfields)
            #以下这句代码，需重新考虑和验证outfields="*"的情况
            spatial_query_sql = "SELECT ST_AsGeoJSON(%s) as geom,%s FROM %s WHERE ST_Contains(ST_GeomFromText(%s),geom) AND %s"%(
                                self.ini.g_field,outfields,self.ini.scheme_name,extentText,where)
            # print spatial_query_sql
            results = conn.execute(spatial_query_sql)

        records = results.fetchall()#获取数据所有记录
        conn.close()#关闭数据库连接,将connection放回连接池
        # print records

        keys = map(lambda key:str(key.upper()),results.keys())
        # print keys

        self.fields = keys   #包含的所有字段
        results = map(lambda vals:dict(zip(keys,map(encodeAttr,vals))),records)
        features = []
        if (self.ini.x_field):
            gtype = "point"
            for item in results:  
                # print item                             
                x = item.get(self.ini.x_field,0)
                y = item.get(self.ini.y_field,0)
                shape=[x,y]     #x,y对应经纬度
                item.pop(self.ini.x_field)         
                item.pop(self.ini.y_field)
                feature = {"geometry":{'type':gtype,'coordinates':shape},
                            'properties':item}
                features.append(feature)

        elif (self.ini.g_field):
            for result in results:  
                feature = {"geometry":eval(result['%s'%self.ini.g_field])}
                result.pop('%s'%self.ini.g_field)
                feature.update({"properties":result})   
                features.append(feature)  #将每次实例化得到的graphic实例添加到layer的缓存中  
        

        self.layer.add_features(features)
        self.layer.get_type()
        print features[0]
        return self.layer.FEATURES



    # def gen_filter(self,filter_str):
    #     '''
    #     获得filter函数，即得到selector
    #     '''

    #     pass
        


class Engine:
    cache = {}

    @classmethod
    def create(cls,dsn):
        '''
        create databse engine
        @param {str} dsn database connection string
        '''
        engine = cls.cache.get(dsn)
        if engine is None:
            from sqlalchemy import create_engine
            engine = create_engine(dsn)
            cls.cache[dsn] = engine
        return engine



def encodeAttr(val):
    import datetime
    from decimal import Decimal
    if val is None:
        return ""
    elif isinstance(val,datetime.datetime):
        return val.strftime("%Y-%m-%d %H:%M:%S")
    elif isinstance(val,datetime.date):
        return val.strftime("%Y-%m-%d")
    elif isinstance(val,Decimal):
        return float(str(val))
    elif isinstance(val,unicode):
        try:
            return str(val)
        except:  #中文字符
            return val.encode('gbk') 
    else:
        return val  
