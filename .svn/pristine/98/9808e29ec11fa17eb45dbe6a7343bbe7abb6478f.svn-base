#coding=utf-8
import os,sys
import aggdraw,Image
scope={}  #字典 给eval一个命名空间，一定程度预防安全隐患
class Style:
    def __init__(self,data):
        self.raw = data
        self.__parse()

    def set_layerDef(self,layerDef):
        self.layerDef = layerDef

    def __parse(self):
        self.rule = []
        filter_keys=self.raw.keys()
        for key in filter_keys:
            rule = Rule(key,self.raw.get(key)) 
            rule.set_style(self)
            self.rule.append(rule)

class Rule:
    def __init__(self,key,value):
        self.key = str(key)    #因为此操作使得key多了个引号，所以下面是n-2
        self.value = value
        self.__parse()
        self.symbol.set_rule(self)  

    def __parse(self):
        self.symbol = Symbol.create_symbol(self.value)

        import re                                        
        p=re.compile(r'\[(\w+)\]')
        para = p.findall(self.key)              #有待改进成re模块的sub函数处理，但尚无思路如何实现。
        n=len(str(para))
        if self.key != "ELSE":                   
            self.filter = eval("lambda graphic:graphic.attributes.get('%s')%s"%(para[0],self.key[n-2:]))
        else:
            self.filter = None    
    
    def set_style(self,style):
        self.style = style    


class Symbol:
    def __init__(self,data):
        self.raw = data
        self.parse()    

    def parse(self):
        pass

    def set_rule(self,rule):
        self.rule = rule  
        
    @classmethod
    def create_symbol(cls,kw):
        if kw.has_key("icon"):     #点图层
            return PointSymbol(kw)
        elif kw.has_key("color"):   #线图层
            return LineSymbol(kw)     

             
class PointSymbol(Symbol):
    def __init__(self,data):
        Symbol.__init__(self,data)    

    def parse(self):
        import Image
        dirpath = os.path.dirname(__file__)
        path = self.raw.get("icon")
        icon_path=os.path.join(dirpath,path)  #拼接获得图标路径
        if Image.open(icon_path):  #考虑是否能成功打开，错误异常捕获
            self.icon = Image.open(icon_path)
            self.size = self.raw.get("size",self.icon.size)   #图标尺寸

    def draw(self,graphic,scale,bbox,img):
        screen_coord = gemtry_to_screen(scale,bbox,graphic.geometry.location)
        img.paste(self.icon,(screen_coord[0]-self.size[0]/2,screen_coord[1]-self.size[1]/2),mask=self.icon)   #放在图层最上面
        return img     
            
class LineSymbol(Symbol):
    def __init__(self,data):
        Symbol.__init__(self,data)

    def parse(self):
        self.color = self.raw.get("color")
        self.width = self.raw.get("width")
        self.alpha = self.raw.get("alpha")

    def draw(self,queryParameter,size):
        size = size  #整张图片尺寸
        bbox = queryParameter.bbox
        insr = queryParameter.insr
        outsr = queryParameter.outsr
        image = Image.new("RGBA", size, (255,255,255,0))
        linelist = []
        for point in self.location:
            coord = gemtry_to_screen(size,bbox,self.point)
            linelist.append(coord)
        draw = aggdraw.Draw(img)
        line_style = aggdraw.Pen("red",4)  #应该由配置文件决定
        draw.line(linelist, line_style)
        draw.flush()


def gemtry_to_screen(scale,bbox,point):
    """
    @param point: 2-list 二元列表，存放的是点位的xy坐标（墨卡托或地理皆可）
    
    因为具体draw方法在PointSymbol或LineSymbol中实现，因此该逻辑不放在layer类的文件中
    bbox和point的insr和outsr逻辑大概也在这里，bbox的也可在layer层实现
    """         
    screenX = int(scale * (point[0] - bbox[0]))
    screenY = int(scale * (bbox[3] - point[1]))
    return [screenX, screenY]      
  