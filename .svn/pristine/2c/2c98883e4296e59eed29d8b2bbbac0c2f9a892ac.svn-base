#coding=utf-8
from functools import partial
from graphic import *
from extent import *
import copy

class TableCache(object):
    '''
    Database Table(or view) Cache Class

    '''
    SQL = "SELECT %s from %s"

    def __init__(self,definition):
        '''
        isTable=True可根据definition中的信息来判断
        '''
        self.engine = definition.engine
        self.name = definition.scheme_name     #数据库中表名，也做此表layer的名字
        self.definition = definition   #该TableCache实例是哪个layer的缓存

        self.scheme_type = definition.scheme_type
        # self.pk_dict = {}
        self.lonlat_dict = {}   #经纬度做键，graphics做值
        # self.list = []

    # def query(self,selector,outfields=None):
    #     '''
    #     根据选择条件和返回字段,查询记录.
    #     ?如果未指定返回字段的情况下,返回所有？返回主键？返回主键即要指定主键字段或者自动识别主键字段，如果没有主键(比如视图)又怎么办？

    #     @param {function} selector 选择条件
    #     @param {list<str>} outfields 返回字段列表,默认为None
    #     '''
    #     if outfields is None:
    #         outfields = self.fields
    #     result = [map(lambda field:record.get(field),outfields) for record in filter(selector,self.list)]
    #     # print [dict(zip(outfields,record)) for record in result]
    #     return result,outfields



    def query(self,queryParameter):
        '''
        @queryParameter:QueryParameter类的实例，每一次query的查询条件
        需要从layer的缓存GRAPHICS中过滤提取有效字段，而不是从results

        原本设计：未实现，因暂且不知如何将多个查询条件组成一个selector函数，只进行一次filter
        @param {function} selector 选择条件
        '''
        graphics = copy.deepcopy(self.definition.layer.GRAPHICS)

        keys_copy = self.fields
        if graphics is None:    #如果尚无缓存则从数据库取出数据
            graphics = copy.deepcopy(TableCache(self.engine,self.name).sync())

        extent =Extent(queryParameter.bbox)      #bbox
        where = queryParameter.where             #where    直接在查询数据库的时候给出where过滤条件，不用filter函数，影响缓存内容，即每次query都需重新查询数据库。
        outfields = queryParameter.outfields     #outfields    (尚未考虑insr,outsr)
        
        results = []    
        for graphic in graphics:
            if extent.contain(graphic.geometry.location):  #过滤bbox
                results.append(graphic) 
        export_results = copy.deepcopy(results)   #将只过滤bbox范围但仍保存所有字段的results缓存共export使用
        
        import re                                          #过滤where条件
        p=re.compile(r'\[(\w+)\]')
        para = p.findall(where)                            #where条件，程序则要求过滤的是attributes中的属性，不能再包含shape
        n=len(str(para))
        filter_where = eval("lambda graphic:graphic.attributes.get('%s')%s"%(para[0],where[n-2:]))
        results=filter(filter_where,results)

        if outfields[0] is not "*":                         #暂且默认queryResult里必然包含x,y字段（即geometry属性）
            # map(lambda x:keys_copy.remove(x),outfields)  #keys_copy剩下要删除的键
            for outfield in outfields:                #keys_copy剩下要删除的键
                if outfield in keys_copy:             
                    keys_copy.remove(outfield)

            for i in xrange(len(results)):
                for key in keys_copy:
                    results[i].attributes.pop(key)    #删除对应的键值     

        results=reduce(lambda x,y:x+y,map(lambda x:[[x.geometry.location,x.attributes.values()]],results))   #去除键，重新组织键值 
         
        aliases_dict = self.definition.aliases
        aliases_dict_keys = aliases_dict.keys()
        for key in keys_copy:
            if key in aliases_dict_keys:
                aliases_dict.pop(key)   #删除对应的别名键值

        return aliases_dict,results,export_results


    def sync(self,fields='*'):
        '''
        同步数据库,从数据库中获取最新的记录;可以指定同步字段,默认同步所有字段信息;
        ?是否需要在第一次调用时,强制同步所有字段信息.
            Y:  之后的查询可以支持任何字段值的返回,但不保证数据的实时性;
            N:  会加载不必要的数据,占用过多系统资源;
            
        @param {list<str>} fields 更新字段列表
        '''
        conn = self.engine.connect()
        results = conn.execute(self.SQL%(fields,self.name))
        # self.fields = result.keys()
        # self.list = [dict(zip(self.fields,record)) for record in result.fetchall()]
        # return self

        records = results.fetchall()#获取数据所有记录
        conn.close()#关闭数据库连接,将connection放回连接池
        keys = map(lambda key:key.upper(),results.keys())
        self.fields = keys
        results = map(lambda vals:dict(zip(keys,map(encodeAttr,vals))),records)
        self.list = results  #暂且未用上
        
        GRAPHICS = []

        features = []
        for item in results:                               
            x = item.get(self.definition.x_field,0)
            y = item.get(self.definition.y_field,0)
            shape=[x,y]     #x,y对应经纬度
            item.pop(self.definition.x_field)         
            item.pop(self.definition.y_field) 
        
            attributes = item   #属性数据   #此处对item进行处理，一个item一个对应的graphic类
            geometry = Geometry(self.definition.gemetryType,shape)  #地理坐标  #先用shape实例化geomtry，剩余做attribute
            sid = item.get(self.definition.p_field,0) 
            graphic_instance = Graphic(sid,geometry,attributes)    #用主键做关键字
            GRAPHICS.append(graphic_instance)  #将每次实例化得到的graphic实例添加到layer的缓存中  
        self.definition.layer.add_graphics(GRAPHICS)

    def gen_filter(self,filter_str):
        '''
        获得filter函数，即得到selector
        '''

        pass
        
class Engine:
    cache = {}

    @classmethod
    def create(cls,dsn):
        '''
        create databse engine
        @param {str} dsn database connection string
        '''
        engine = cls.cache.get(dsn)
        if engine is None:
            from sqlalchemy import create_engine
            engine = create_engine(dsn)
            cls.cache[dsn] = engine
        return engine



def encodeAttr(val):
    import datetime
    from decimal import Decimal
    if val is None:
        return ""
    elif isinstance(val,datetime.datetime):
        return val.strftime("%Y-%m-%d %H:%M:%S")
    elif isinstance(val,Decimal):
        return float(str(val))
    else:
        return val  






# if __name__ == '__main__':
#     dsn = "oracle://gis:gis@172.16.60.35:1521/yhte"
#     name = "V_TASK_POINT"
#     engine = Engine.create(dsn)

#     cache = TableCache(engine,name).sync()
#     f = lambda record:record.get("task_point_id")%2 == 0
#     cache.query(f,['task_point_id'])