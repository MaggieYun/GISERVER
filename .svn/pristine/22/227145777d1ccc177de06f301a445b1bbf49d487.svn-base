#coding=utf-8
from functools import partial
from graphic import *
from extent import *
import copy

class TableCache(object):
    '''
    Database Table(or view) Cache Class

    '''
    SQL = "SELECT %s from %s"

    def __init__(self,definition):
        '''
        isTable=True可根据definition中的信息来判断
        '''
        self.engine = definition.engine
        self.name = definition.scheme_name     #数据库中表名，也做此表layer的名字
        self.definition = definition   #该TableCache实例是哪个layer的缓存

        self.scheme_type = definition.scheme_type
        # self.pk_dict = {}
        self.lonlat_dict = {}   #经纬度做键，graphics做值
        # self.list = []

    # def query(self,selector,outfields=None):
    #     '''
    #     根据选择条件和返回字段,查询记录.
    #     ?如果未指定返回字段的情况下,返回所有？返回主键？返回主键即要指定主键字段或者自动识别主键字段，如果没有主键(比如视图)又怎么办？

    #     @param {function} selector 选择条件
    #     @param {list<str>} outfields 返回字段列表,默认为None
    #     '''
    #     if outfields is None:
    #         outfields = self.fields
    #     result = [map(lambda field:record.get(field),outfields) for record in filter(selector,self.list)]
    #     # print [dict(zip(outfields,record)) for record in result]
    #     return result,outfields



    def query(self,queryParameter):
        '''
        @queryParameter:QueryParameter类的实例，每一次query的查询条件
        需要从layer的缓存GRAPHICS中过滤提取有效字段，而不是从results

        原本设计：未实现，因暂且不知如何将多个查询条件组成一个selector函数，只进行一次filter
        @param {function} selector 选择条件
        '''
        graphics = copy.deepcopy(self.definition.layer.GRAPHICS)

        if graphics is None:    #如果尚无缓存则从数据库取出数据
            graphics = copy.deepcopy(TableCache(self.engine,self.name).sync())

        #以下三要素相当于selector的主要内容，可改造成selector
        extent =Extent(queryParameter.bbox)      #bbox
        where = queryParameter.where             #where    
        outfields = queryParameter.outfields     #outfields    (尚未考虑insr,outsr)
        
        results = []    
        for graphic in graphics:
            if extent.contain(graphic.geometry.location):  #过滤bbox
                results.append(graphic) 
        
        export_results = copy.deepcopy(results)   #将只过滤bbox范围但仍保存所有字段的results缓存共export使用
        
        import re                                          #过滤where条件
        p=re.compile(r'\[(\w+)\]')
        para = p.findall(where)                            #where条件，程序则要求过滤的是attributes中的属性，不能再包含shape
        n=len(str(para))
        filter_where = eval("lambda graphic:graphic.attributes.get('%s')%s"%(para[0],where[n-2:]))
        results=filter(filter_where,results)   

        #用户url中传来的参数outfields中不必（也不能）包含x，y字段，会自动查询并显示。
        last_results = []  #其中直接存放字典类型，将attributes值取出
        if outfields[0] is not "*":                         #暂且默认queryResult里必然包含x,y字段（即geometry属性）
            for result in results:                  #注意保持取出字段的排列顺序
                one_result =[]                      #一个graphic的attributes中应取出的outfields字段
                one_result.append(result.geometry.location)   #首先将location字段添加
                for outfield in outfields:             #按道理outfields必然是self.fileds的子集
                    one = result.attributes.get(outfield)
                    if one:                             #验证一下attributes中是否包含该字段。
                        one_result.append(one)
                last_results.append(one_result)             #二维数组 
        else:
            last_results= reduce(lambda x,y:x+y,map(lambda x:[[x.geometry.location,x.attributes.values()]],results))   #去除键，重新组织键值 
            fields = results[0].attributes.keys()
            
        
        aliases_dict = self.definition.aliases          #aliases_dict>outfields
        aliases_dict_keys = aliases_dict.keys()
        
        #方法一
        new_aliases_list =["SHAPE","SHAPE"]           #顺序按照outfields的顺序,使用列表是为了保证顺序
        aliases=[]
        fields = []

        if outfields[0] is not "*":               #可将此处逻辑放在上面if outfields[0] is not "*"的判断处理逻辑中，减少遍历次数
            for outfield in outfields:  
                if outfield in aliases_dict_keys:
                    new_aliases_list.append(outfield)
                    new_aliases_list.append(aliases_dict.get(outfield))
        
            n = len(new_aliases_list)                     #数据量十分小，应不会影响多少效率
            for i in xrange(0,n,2):
                fields.append(new_aliases_list[i])        #fields即是outfields.append("shape"),顺序也对应
            for i in xrange(1,n+1,2):
                aliases.append(new_aliases_list[i])
        
        else:        #需保证顺序与last_results字段顺序一致
            aliases = aliases_dict.values()    #该种做法完全依赖配置文件            
            aliases[0]="SHAPE"
            fields = aliases_dict.keys()
            fields[0]="SHAPE"

            # print "_________________________"
            # print self.definition.x_field
            # print self.fields
            # fields1 = self.fields.remove(self.definition.x_field)
            # print fields1              #为什么fields1=None？？？？？？？？？？
            # fields = fields1.remove(self.definition.y_field)
            # fields[0]="SHAPE"
        
        return aliases,fields,last_results,export_results


    def sync(self,fields='*'):
        '''
        同步数据库,从数据库中获取最新的记录;可以指定同步字段,默认同步所有字段信息;
        ?是否需要在第一次调用时,强制同步所有字段信息.
            Y:  之后的查询可以支持任何字段值的返回,但不保证数据的实时性;
            N:  会加载不必要的数据,占用过多系统资源;
            
        @param {list<str>} fields 更新字段列表
        '''
        conn = self.engine.connect()
        results = conn.execute(self.SQL%(fields,self.name))
        # self.fields = result.keys()
        # self.list = [dict(zip(self.fields,record)) for record in result.fetchall()]
        # return self

        records = results.fetchall()#获取数据所有记录
        conn.close()#关闭数据库连接,将connection放回连接池
        keys = map(lambda key:key.upper(),results.keys())
        self.fields = keys   #包含的所有字段
        print "self.fields____________",self.fields
        results = map(lambda vals:dict(zip(keys,map(encodeAttr,vals))),records)
        self.list = results  #暂且未用上
        
        GRAPHICS = []

        features = []
        for item in results:                               
            x = item.get(self.definition.x_field,0)
            y = item.get(self.definition.y_field,0)
            shape=[x,y]     #x,y对应经纬度
            item.pop(self.definition.x_field)         
            item.pop(self.definition.y_field) 
        
            attributes = item   #属性数据   #此处对item进行处理，一个item一个对应的graphic类
            geometry = Geometry(self.definition.geometryType,shape)  #地理坐标  #先用shape实例化geomtry，剩余做attribute
            sid = item.get(self.definition.p_field,0) 
            graphic_instance = Graphic(sid,geometry,attributes)    #用主键做关键字
            GRAPHICS.append(graphic_instance)  #将每次实例化得到的graphic实例添加到layer的缓存中  
        self.definition.layer.add_graphics(GRAPHICS)

    def gen_filter(self,filter_str):
        '''
        获得filter函数，即得到selector
        '''

        pass
        
class Engine:
    cache = {}

    @classmethod
    def create(cls,dsn):
        '''
        create databse engine
        @param {str} dsn database connection string
        '''
        engine = cls.cache.get(dsn)
        if engine is None:
            from sqlalchemy import create_engine
            engine = create_engine(dsn)
            cls.cache[dsn] = engine
        return engine



def encodeAttr(val):
    import datetime
    from decimal import Decimal
    if val is None:
        return ""
    elif isinstance(val,datetime.datetime):
        return val.strftime("%Y-%m-%d %H:%M:%S")
    elif isinstance(val,Decimal):
        return float(str(val))
    else:
        return val  






# if __name__ == '__main__':
#     dsn = "oracle://gis:gis@172.16.60.35:1521/yhte"
#     name = "V_TASK_POINT"
#     engine = Engine.create(dsn)

#     cache = TableCache(engine,name).sync()
#     f = lambda record:record.get("task_point_id")%2 == 0
#     cache.query(f,['task_point_id'])