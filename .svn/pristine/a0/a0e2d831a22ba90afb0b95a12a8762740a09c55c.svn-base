#coding=utf-8
from extent import *
import copy
class GiserverStore:
    '''
    用于处理数据库操作及取出数据的处理
    '''
    QEURY_SQL = "select * from %s where %s"

    @classmethod
    def set_engine(cls,engine):
        '''
        设置engine
        '''
        cls.engine = engine

    @classmethod
    def get_data_from_database(cls,sql):
        '''
        从数据库中取出数据，并组成字典的形式
        '''
        conn = cls.engine.connect()#从连接池获取连接
        results = conn.execute(sql)#执行查询
        records = results.fetchall()#获取数据所有记录
        conn.close()#关闭数据库连接,将connection放回连接池
        keys = map(lambda key:key.upper(),results.keys())
        results = map(lambda vals:dict(zip(keys,map(encodeAttr,vals))),records)
        return results,keys

    @classmethod
    def filter_data(cls,layer):
        # extent =Extent(layer.queryParameter.bbox)      #bbox
        where = layer.queryParameter.where             #where    直接在查询数据库的时候给出where过滤条件，不用filter函数，影响缓存内容，即每次query都需重新查询数据库。
        outfields = layer.queryParameter.outfields     #outfields    (尚未考虑insr,outsr)

        if where is not None:                   
            sql = cls.QEURY_SQL%(layer.definition.scheme_name,where)
        else:                                   #用户未给出where条件的情况
            sql = cls.QEURY_SQL%layer.definition.scheme_name 
        results,keys=cls.get_data_from_database(sql)     #查询出的最原始的结果，缓存此数据    
        
        keys_copy=copy.deepcopy(keys)

        features = []
        for item in results:                               
            x = item.get(layer.definition.x_field,0)
            y = item.get(layer.definition.y_field,0)
            shape=[x,y]
            item.pop(layer.definition.x_field)         #感觉此方法不好，可能影响后续很多操作和查询
            item.pop(layer.definition.y_field) 
            item.update({"shape":shape})               #将x,y放在一个列表里
            if layer.extent.is_within_bbox([x,y]): #过滤bbox
                features.append(item)       

        if outfields[0] is not "*":
            map(lambda x:keys_copy.remove(x),outfields)  #剩下要删除的键
            for i in xrange(len(features)):
                for key in keys_copy:
                    features[i].pop(key)    #删除对应的键值

        last_features=reduce(lambda x,y:x+y,map(lambda x:[x.values()],features))   #去除键，重新组织键值 

        aliases_dict = layer.definition.aliases
        aliases_dict_keys = aliases_dict.keys()
        for key in keys_copy:
            if key in aliases_dict_keys:
                aliases_dict.pop(key)   #删除对应的别名键值

        return aliases_dict,last_features



def encodeAttr(val):
    import datetime
    from decimal import Decimal
    if val is None:
        return ""
    elif isinstance(val,datetime.datetime):
        return val.strftime("%Y-%m-%d %H:%M:%S")
    elif isinstance(val,Decimal):
        return float(str(val))
    else:
        return val        