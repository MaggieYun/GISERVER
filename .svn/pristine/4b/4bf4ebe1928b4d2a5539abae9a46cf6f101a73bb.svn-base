#coding=utf-8
from extent import *
import copy
class Layer:

    QEURY_SQL = "select * from %s where %s"

    def __init__(self,definition):
        self.cache = None
        self.definition = definition
        self.definition.set_layer(self)
        self.image = None

        self.queryParameter = None
        self.extent = None

    def reload(self):
        pass

    def query(self,queryParameter):

        self.queryParameter = queryParameter
        self.extent =Extent(self.queryParameter.bbox)  #bbox
        where = self.queryParameter.where             #where    直接在查询数据库的时候给出where过滤条件，不用filter函数，影响缓存内容，即每次query都需重新查询数据库。
        outfields = self.queryParameter.outfields     #outfields    (尚未考虑insr,outsr)

        conn = self.definition.conn
        if where is not None:                   
            sql = Layer.QEURY_SQL%(self.definition.scheme_name,where)
        else:                                   #用户未给出where条件的情况
            sql = Layer.QEURY_SQL%self.definition.scheme_name 

        results,keys=get_data_from_database(conn,sql)     #查询出的最原始的结果，缓存此数据

        keys_copy=copy.deepcopy(keys)
        aliases_dict = self.definition.aliases
        features = []

        for item in results:                               
            x = item.get(self.definition.x_field,0)
            y = item.get(self.definition.y_field,0)
            shape=[x,y]
            item.pop(self.definition.x_field)         #感觉此方法不好，可能影响后续很多操作和查询
            item.pop(self.definition.y_field) 
            item.update({"shape":shape})               #将x,y放在一个列表里
            if self.extent.is_within_bbox([x,y]): #过滤bbox
                features.append(item)       

        if outfields[0] is not "*":
            map(lambda x:keys_copy.remove(x),outfields)  #剩下要删除的键
            for i in xrange(len(features)):
                for key in keys_copy:
                    features[i].pop(key)    #删除对应的键值

        last_features=reduce(lambda x,y:x+y,map(lambda x:[x.values()],features))   #去除键，重新组织键值 

        aliases_dict_keys = aliases_dict.keys()
        for key in keys_copy:
            if key in aliases_dict_keys:
                aliases_dict.pop(key)   #删除对应的别名键值
                     
        fields = aliases_dict.keys()
        aliases = aliases_dict.values()
        gemetryType = self.definition.gemetryType 
        


        queryResult = QueryResult(aliases,fields,last_features,gemetryType)

        return queryResult





    def export(self,queryParameter):
        self.size = queryParameter.size
        self.bbox = queryParameter.bbox
        self.outsr = outsr
        self.image = Image.new("RGBA", self.size, (255,255,255,0))
        self.definition.style.rule.symbol.draw(self)
    
    def toScreen(self):
        pass

    def toGemtry(self):
        pass

class QueryParameter:
    def __init__(self,bbox,where,insr,outfields,outsr):
        self.bbox = bbox
        self.where = where
        self.insr = insr
        self.outfields = outfields.split(",")
        self.outsr = outsr

    @classmethod
    def create(cls,requestHandler):
        self.layer = requestHandler.get_argument("layer")
        self.bbox = requestHandler.get_argument("bbox")
        self.where = requestHandler.get_argument("where",None)
        self.insr = requestHandler.get_argument("insr")
        self.outfields = requestHandler.get_argument("outfields")
        self.outsr = requestHandler.get_argument("outsr")  

    def toString(self):
        pass    


class QueryResult:
    def __init__(self,aliases,fields,features,layer_type):
        self.aliases = aliases
        self.fields = fields
        self.features = features
        self.type = layer_type 

    def toString(self):
        pass    



def encodeAttr(val):
    import datetime
    from decimal import Decimal
    if val is None:
        return ""
    elif isinstance(val,datetime.datetime):
        return val.strftime("%Y-%m-%d %H:%M:%S")
    elif isinstance(val,Decimal):
        return float(str(val))
    else:
        return val

def get_data_from_database(conn,sql):
    '''
    从数据库中取出数据，并组成字典的形式
    '''
    results = conn.execute(sql)#执行查询
    records = results.fetchall()#获取数据所有记录
    conn.close()#关闭数据库连接,将connection放回连接池
    keys = map(lambda key:key.upper(),results.keys())
    results = map(lambda vals:dict(zip(keys,map(encodeAttr,vals))),records)
    return results,keys
